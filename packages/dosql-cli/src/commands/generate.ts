import { promises as fs } from 'node:fs';
import { join, basename } from 'node:path';

export interface GenerateOptions {
  schemaDir: string;
  outputDir: string;
}

export interface GenerateResult {
  success: boolean;
  generatedFiles: string[];
  tablesProcessed: string[];
}

interface ColumnDefinition {
  type: 'integer' | 'text' | 'real' | 'blob' | 'boolean';
  primaryKey?: boolean;
  nullable?: boolean;
}

interface TableSchema {
  tableName: string;
  columns: Record<string, ColumnDefinition>;
}

function mapSqlTypeToTs(type: string, nullable: boolean): string {
  const baseType = (() => {
    switch (type) {
      case 'integer':
        return 'number';
      case 'real':
        return 'number';
      case 'boolean':
        return 'boolean';
      case 'blob':
        return 'Uint8Array';
      case 'text':
      default:
        return 'string';
    }
  })();

  return nullable ? `${baseType} | null` : baseType;
}

function tableNameToInterfaceName(tableName: string): string {
  // Convert snake_case to PascalCase and singularize (simple version)
  const pascal = tableName
    .split('_')
    .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
    .join('');

  // Simple singularization: remove trailing 's' if present
  if (pascal.endsWith('s') && pascal.length > 1) {
    return pascal.slice(0, -1);
  }
  return pascal;
}

async function parseSchemaFile(filePath: string): Promise<TableSchema[]> {
  const content = await fs.readFile(filePath, 'utf-8');
  const schemas: TableSchema[] = [];

  // Simple regex-based parser for schema definitions
  // Matches: export const tableName = { tableName: '...', columns: { ... } } as const;
  const exportRegex = /export\s+const\s+(\w+)\s*=\s*\{[\s\S]*?tableName:\s*['"]([^'"]+)['"][\s\S]*?columns:\s*\{([\s\S]*?)\}\s*,?\s*\}\s*as\s+const/g;

  let match;
  while ((match = exportRegex.exec(content)) !== null) {
    const tableName = match[2];
    const columnsBlock = match[3];

    if (!tableName || !columnsBlock) continue;

    const columns: Record<string, ColumnDefinition> = {};

    // Parse individual columns
    const columnRegex = /(\w+):\s*\{\s*type:\s*['"](\w+)['"](?:,\s*primaryKey:\s*(true|false))?(?:,\s*nullable:\s*(true|false))?\s*\}/g;
    let colMatch;
    while ((colMatch = columnRegex.exec(columnsBlock)) !== null) {
      const colName = colMatch[1];
      const colType = colMatch[2] as ColumnDefinition['type'];
      const isPrimaryKey = colMatch[3] === 'true';
      const isNullable = colMatch[4] === 'true';

      if (colName) {
        columns[colName] = {
          type: colType,
          primaryKey: isPrimaryKey,
          nullable: isNullable,
        };
      }
    }

    schemas.push({
      tableName,
      columns,
    });
  }

  return schemas;
}

function generateInterface(schema: TableSchema): string {
  const interfaceName = tableNameToInterfaceName(schema.tableName);
  const lines: string[] = [`export interface ${interfaceName} {`];

  for (const [colName, colDef] of Object.entries(schema.columns)) {
    const tsType = mapSqlTypeToTs(colDef.type, colDef.nullable ?? false);
    lines.push(`  ${colName}: ${tsType};`);
  }

  lines.push('}');
  return lines.join('\n');
}

export async function generateTypes(options: GenerateOptions): Promise<GenerateResult> {
  const { schemaDir, outputDir } = options;

  // Check if schema directory exists
  const exists = await fs.access(schemaDir).then(() => true).catch(() => false);
  if (!exists) {
    throw new Error(`Schema directory not found: ${schemaDir}`);
  }

  // Ensure output directory exists
  await fs.mkdir(outputDir, { recursive: true });

  // Find all schema files
  const entries = await fs.readdir(schemaDir, { withFileTypes: true });
  const schemaFiles = entries
    .filter(e => e.isFile() && e.name.endsWith('.ts'))
    .map(e => join(schemaDir, e.name));

  // Parse all schemas
  const allSchemas: TableSchema[] = [];
  for (const file of schemaFiles) {
    const schemas = await parseSchemaFile(file);
    allSchemas.push(...schemas);
  }

  // Generate TypeScript interfaces
  const interfaces = allSchemas.map(generateInterface);
  const header = `// This file is auto-generated by dosql generate
// Do not edit manually

`;
  const output = header + interfaces.join('\n\n') + '\n';

  // Write output file
  const outputPath = join(outputDir, 'types.ts');
  await fs.writeFile(outputPath, output);

  return {
    success: true,
    generatedFiles: ['types.ts'],
    tablesProcessed: allSchemas.map(s => s.tableName),
  };
}
