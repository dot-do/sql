
/**
 * Benchmark Worker - DoSQL vs DO SQLite vs D1
 * Auto-generated by worker-compare.ts
 */

import { DurableObject } from 'cloudflare:workers';

// =============================================================================
// DoSQL Durable Object (uses DoSQL engine)
// =============================================================================

export class DoSQLBenchmarkDO extends DurableObject {
  private db: any;
  private rowCount = 1000;

  async ensureDb() {
    if (!this.db) {
      const { Database } = await import('./src/database.js');
      this.db = new Database(':memory:');
      // Auto-setup when DO wakes up - this is the overhead of in-memory DB
      await this.doSetup(this.rowCount);
    }
  }

  private async doSetup(rowCount: number) {
    this.rowCount = rowCount;
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS bench (
        id INTEGER PRIMARY KEY,
        name TEXT,
        value REAL,
        data TEXT
      )
    `);

    const insert = this.db.prepare('INSERT INTO bench (id, name, value, data) VALUES (?, ?, ?, ?)');
    for (let i = 1; i <= rowCount; i++) {
      insert.run(i, `name_${i}`, Math.random() * 1000, `data_${i}`);
    }
  }

  async setup(rowCount: number) {
    this.db = null; // Force re-init
    await this.ensureDb();
    this.rowCount = rowCount;
    // Re-setup with new row count
    this.db.exec('DROP TABLE IF EXISTS bench');
    await this.doSetup(rowCount);
    return { rowCount };
  }

  async selectByPK(id: number) {
    await this.ensureDb();
    const start = performance.now();
    const result = this.db.prepare('SELECT * FROM bench WHERE id = ?').all(id);
    return { latencyMs: performance.now() - start, rows: result.length };
  }

  async rangeSelect(min: number, max: number) {
    await this.ensureDb();
    const start = performance.now();
    const result = this.db.prepare('SELECT * FROM bench WHERE id >= ? AND id <= ?').all(min, max);
    return { latencyMs: performance.now() - start, rows: result.length };
  }

  async aggregate() {
    await this.ensureDb();
    const start = performance.now();
    const result = this.db.prepare('SELECT COUNT(*), AVG(value), MAX(value), MIN(value) FROM bench').all();
    return { latencyMs: performance.now() - start, rows: 1 };
  }

  async insert(id: number, name: string, value: number, data: string) {
    await this.ensureDb();
    const start = performance.now();
    // Use plain INSERT - IDs are unique (100000+)
    this.db.prepare('INSERT INTO bench (id, name, value, data) VALUES (?, ?, ?, ?)').run(id, name, value, data);
    return { latencyMs: performance.now() - start, rows: 1 };
  }
}

// =============================================================================
// DO SQLite Durable Object (native DO SQLite)
// =============================================================================

export class DOSqliteBenchmarkDO extends DurableObject {
  async setup(rowCount: number) {
    // Clean slate for benchmark
    this.ctx.storage.sql.exec('DROP TABLE IF EXISTS bench');
    this.ctx.storage.sql.exec(`
      CREATE TABLE bench (
        id INTEGER PRIMARY KEY,
        name TEXT,
        value REAL,
        data TEXT
      )
    `);

    for (let i = 1; i <= rowCount; i++) {
      this.ctx.storage.sql.exec(
        'INSERT INTO bench (id, name, value, data) VALUES (?, ?, ?, ?)',
        i, `name_${i}`, Math.random() * 1000, `data_${i}`
      );
    }

    return { rowCount };
  }

  async selectByPK(id: number) {
    const start = performance.now();
    const result = this.ctx.storage.sql.exec('SELECT * FROM bench WHERE id = ?', id).toArray();
    return { latencyMs: performance.now() - start, rows: result.length };
  }

  async rangeSelect(min: number, max: number) {
    const start = performance.now();
    const result = this.ctx.storage.sql.exec('SELECT * FROM bench WHERE id >= ? AND id <= ?', min, max).toArray();
    return { latencyMs: performance.now() - start, rows: result.length };
  }

  async aggregate() {
    const start = performance.now();
    const result = this.ctx.storage.sql.exec('SELECT COUNT(*), AVG(value), MAX(value), MIN(value) FROM bench').toArray();
    return { latencyMs: performance.now() - start, rows: 1 };
  }

  async insert(id: number, name: string, value: number, data: string) {
    const start = performance.now();
    // Use plain INSERT - IDs are unique (100000+)
    this.ctx.storage.sql.exec('INSERT INTO bench (id, name, value, data) VALUES (?, ?, ?, ?)', id, name, value, data);
    return { latencyMs: performance.now() - start, rows: 1 };
  }
}

// =============================================================================
// Main Worker
// =============================================================================

export default {
  async fetch(request: Request, env: any) {
    const url = new URL(request.url);
    const path = url.pathname;

    // Parse params
    const params = Object.fromEntries(url.searchParams);
    const system = params.system || 'dosql'; // dosql, do-sqlite, d1
    const operation = params.op || 'select';
    const id = parseInt(params.id || '1');
    const min = parseInt(params.min || '1');
    const max = parseInt(params.max || '100');
    const rowCount = parseInt(params.rowCount || '1000');

    try {
      let result;

      if (system === 'dosql') {
        const stub = env.DOSQL_BENCHMARK.get(env.DOSQL_BENCHMARK.idFromName('bench'));

        switch (operation) {
          case 'setup':
            result = await stub.setup(rowCount);
            break;
          case 'select':
            result = await stub.selectByPK(id);
            break;
          case 'range':
            result = await stub.rangeSelect(min, max);
            break;
          case 'aggregate':
            result = await stub.aggregate();
            break;
          case 'insert':
            result = await stub.insert(id + 100000, `bench_${Date.now()}`, Math.random(), `data_${Date.now()}`);
            break;
        }
      } else if (system === 'do-sqlite') {
        const stub = env.DOSQLITE_BENCHMARK.get(env.DOSQLITE_BENCHMARK.idFromName('bench'));

        switch (operation) {
          case 'setup':
            result = await stub.setup(rowCount);
            break;
          case 'select':
            result = await stub.selectByPK(id);
            break;
          case 'range':
            result = await stub.rangeSelect(min, max);
            break;
          case 'aggregate':
            result = await stub.aggregate();
            break;
          case 'insert':
            result = await stub.insert(id + 100000, `bench_${Date.now()}`, Math.random(), `data_${Date.now()}`);
            break;
        }
      } else if (system === 'd1') {
        const d1 = env.BENCHMARK_D1;
        const start = performance.now();

        switch (operation) {
          case 'setup':
            // Use batch for DDL to avoid multi-statement issues
            await d1.batch([
              d1.prepare('DROP TABLE IF EXISTS bench'),
              d1.prepare(`CREATE TABLE IF NOT EXISTS bench (
                id INTEGER PRIMARY KEY,
                name TEXT,
                value REAL,
                data TEXT
              )`)
            ]);
            for (let i = 1; i <= rowCount; i += 100) {
              const batch = [];
              for (let j = i; j < Math.min(i + 100, rowCount + 1); j++) {
                batch.push(d1.prepare('INSERT INTO bench (id, name, value, data) VALUES (?, ?, ?, ?)')
                  .bind(j, `name_${j}`, Math.random() * 1000, `data_${j}`));
              }
              await d1.batch(batch);
            }
            result = { latencyMs: performance.now() - start, rowCount };
            break;
          case 'select':
            const selectResult = await d1.prepare('SELECT * FROM bench WHERE id = ?').bind(id).all();
            result = { latencyMs: performance.now() - start, rows: selectResult.results.length };
            break;
          case 'range':
            const rangeResult = await d1.prepare('SELECT * FROM bench WHERE id >= ? AND id <= ?').bind(min, max).all();
            result = { latencyMs: performance.now() - start, rows: rangeResult.results.length };
            break;
          case 'aggregate':
            const aggResult = await d1.prepare('SELECT COUNT(*), AVG(value), MAX(value), MIN(value) FROM bench').all();
            result = { latencyMs: performance.now() - start, rows: 1 };
            break;
          case 'insert':
            // Use plain INSERT - IDs are unique (100000+)
            await d1.prepare('INSERT INTO bench (id, name, value, data) VALUES (?, ?, ?, ?)')
              .bind(id + 100000, `bench_${Date.now()}`, Math.random(), `data_${Date.now()}`).run();
            result = { latencyMs: performance.now() - start, rows: 1 };
            break;
        }
      }

      return Response.json({ success: true, system, operation, ...result });
    } catch (error) {
      return Response.json({ success: false, error: String(error) }, { status: 500 });
    }
  }
};
