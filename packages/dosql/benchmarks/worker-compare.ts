#!/usr/bin/env npx tsx
/**
 * Cloudflare Workers Benchmark Comparison
 *
 * Compares DoSQL vs DO SQLite vs D1 on actual Cloudflare Workers infrastructure.
 *
 * This benchmark:
 * 1. Deploys a test worker with all three database types
 * 2. Runs identical workloads against each
 * 3. Measures real production latency and throughput
 *
 * Prerequisites:
 * - wrangler logged in: `wrangler login`
 * - D1 database created: `wrangler d1 create dosql-benchmark`
 *
 * Usage:
 *   npx tsx benchmarks/worker-compare.ts
 *   npx tsx benchmarks/worker-compare.ts --quick
 *   npx tsx benchmarks/worker-compare.ts --iterations=1000
 */

import { execSync } from 'child_process';

// =============================================================================
// Configuration
// =============================================================================

interface BenchmarkConfig {
  iterations: number;
  warmupIterations: number;
  rowCount: number;
  concurrency: number[];
}

const DEFAULT_CONFIG: BenchmarkConfig = {
  iterations: 100,
  warmupIterations: 10,
  rowCount: 1000,
  concurrency: [1, 5, 10],
};

const QUICK_CONFIG: BenchmarkConfig = {
  iterations: 20,
  warmupIterations: 5,
  rowCount: 100,
  concurrency: [1, 5],
};

// =============================================================================
// Worker Code Generator
// =============================================================================

/**
 * Generate the benchmark worker code
 */
function generateWorkerCode(): string {
  return `
/**
 * Benchmark Worker - DoSQL vs DO SQLite vs D1
 * Auto-generated by worker-compare.ts
 */

import { DurableObject } from 'cloudflare:workers';

// =============================================================================
// DoSQL Durable Object (uses DoSQL engine)
// =============================================================================

export class DoSQLBenchmarkDO extends DurableObject {
  private db: any;

  async initialize() {
    // Import DoSQL Database class
    const { Database } = await import('./src/database.js');
    this.db = new Database(':memory:');
  }

  async setup(rowCount: number) {
    if (!this.db) await this.initialize();

    this.db.exec(\`
      CREATE TABLE IF NOT EXISTS bench (
        id INTEGER PRIMARY KEY,
        name TEXT,
        value REAL,
        data TEXT
      )
    \`);

    const insert = this.db.prepare('INSERT INTO bench (id, name, value, data) VALUES (?, ?, ?, ?)');
    for (let i = 1; i <= rowCount; i++) {
      insert.run(i, \`name_\${i}\`, Math.random() * 1000, \`data_\${i}\`);
    }

    return { rowCount };
  }

  async selectByPK(id: number) {
    const start = performance.now();
    const result = this.db.prepare('SELECT * FROM bench WHERE id = ?').all(id);
    return { latencyMs: performance.now() - start, rows: result.length };
  }

  async rangeSelect(min: number, max: number) {
    const start = performance.now();
    const result = this.db.prepare('SELECT * FROM bench WHERE id >= ? AND id <= ?').all(min, max);
    return { latencyMs: performance.now() - start, rows: result.length };
  }

  async aggregate() {
    const start = performance.now();
    const result = this.db.prepare('SELECT COUNT(*), AVG(value), MAX(value), MIN(value) FROM bench').all();
    return { latencyMs: performance.now() - start, rows: 1 };
  }

  async insert(id: number, name: string, value: number, data: string) {
    const start = performance.now();
    this.db.prepare('INSERT OR REPLACE INTO bench (id, name, value, data) VALUES (?, ?, ?, ?)').run(id, name, value, data);
    return { latencyMs: performance.now() - start, rows: 1 };
  }
}

// =============================================================================
// DO SQLite Durable Object (native DO SQLite)
// =============================================================================

export class DOSqliteBenchmarkDO extends DurableObject {
  async setup(rowCount: number) {
    this.ctx.storage.sql.exec(\`
      CREATE TABLE IF NOT EXISTS bench (
        id INTEGER PRIMARY KEY,
        name TEXT,
        value REAL,
        data TEXT
      )
    \`);

    for (let i = 1; i <= rowCount; i++) {
      this.ctx.storage.sql.exec(
        'INSERT INTO bench (id, name, value, data) VALUES (?, ?, ?, ?)',
        i, \`name_\${i}\`, Math.random() * 1000, \`data_\${i}\`
      );
    }

    return { rowCount };
  }

  async selectByPK(id: number) {
    const start = performance.now();
    const result = this.ctx.storage.sql.exec('SELECT * FROM bench WHERE id = ?', id).toArray();
    return { latencyMs: performance.now() - start, rows: result.length };
  }

  async rangeSelect(min: number, max: number) {
    const start = performance.now();
    const result = this.ctx.storage.sql.exec('SELECT * FROM bench WHERE id >= ? AND id <= ?', min, max).toArray();
    return { latencyMs: performance.now() - start, rows: result.length };
  }

  async aggregate() {
    const start = performance.now();
    const result = this.ctx.storage.sql.exec('SELECT COUNT(*), AVG(value), MAX(value), MIN(value) FROM bench').toArray();
    return { latencyMs: performance.now() - start, rows: 1 };
  }

  async insert(id: number, name: string, value: number, data: string) {
    const start = performance.now();
    this.ctx.storage.sql.exec('INSERT OR REPLACE INTO bench (id, name, value, data) VALUES (?, ?, ?, ?)', id, name, value, data);
    return { latencyMs: performance.now() - start, rows: 1 };
  }
}

// =============================================================================
// Main Worker
// =============================================================================

export default {
  async fetch(request: Request, env: any) {
    const url = new URL(request.url);
    const path = url.pathname;

    // Parse params
    const params = Object.fromEntries(url.searchParams);
    const system = params.system || 'dosql'; // dosql, do-sqlite, d1
    const operation = params.op || 'select';
    const id = parseInt(params.id || '1');
    const min = parseInt(params.min || '1');
    const max = parseInt(params.max || '100');
    const rowCount = parseInt(params.rowCount || '1000');

    try {
      let result;

      if (system === 'dosql') {
        const stub = env.DOSQL_BENCHMARK.get(env.DOSQL_BENCHMARK.idFromName('bench'));

        switch (operation) {
          case 'setup':
            result = await stub.setup(rowCount);
            break;
          case 'select':
            result = await stub.selectByPK(id);
            break;
          case 'range':
            result = await stub.rangeSelect(min, max);
            break;
          case 'aggregate':
            result = await stub.aggregate();
            break;
          case 'insert':
            result = await stub.insert(id + 100000, \`bench_\${Date.now()}\`, Math.random(), \`data_\${Date.now()}\`);
            break;
        }
      } else if (system === 'do-sqlite') {
        const stub = env.DOSQLITE_BENCHMARK.get(env.DOSQLITE_BENCHMARK.idFromName('bench'));

        switch (operation) {
          case 'setup':
            result = await stub.setup(rowCount);
            break;
          case 'select':
            result = await stub.selectByPK(id);
            break;
          case 'range':
            result = await stub.rangeSelect(min, max);
            break;
          case 'aggregate':
            result = await stub.aggregate();
            break;
          case 'insert':
            result = await stub.insert(id + 100000, \`bench_\${Date.now()}\`, Math.random(), \`data_\${Date.now()}\`);
            break;
        }
      } else if (system === 'd1') {
        const d1 = env.BENCHMARK_D1;
        const start = performance.now();

        switch (operation) {
          case 'setup':
            await d1.exec(\`
              DROP TABLE IF EXISTS bench;
              CREATE TABLE bench (
                id INTEGER PRIMARY KEY,
                name TEXT,
                value REAL,
                data TEXT
              )
            \`);
            for (let i = 1; i <= rowCount; i += 100) {
              const batch = [];
              for (let j = i; j < Math.min(i + 100, rowCount + 1); j++) {
                batch.push(d1.prepare('INSERT INTO bench (id, name, value, data) VALUES (?, ?, ?, ?)')
                  .bind(j, \`name_\${j}\`, Math.random() * 1000, \`data_\${j}\`));
              }
              await d1.batch(batch);
            }
            result = { latencyMs: performance.now() - start, rowCount };
            break;
          case 'select':
            const selectResult = await d1.prepare('SELECT * FROM bench WHERE id = ?').bind(id).all();
            result = { latencyMs: performance.now() - start, rows: selectResult.results.length };
            break;
          case 'range':
            const rangeResult = await d1.prepare('SELECT * FROM bench WHERE id >= ? AND id <= ?').bind(min, max).all();
            result = { latencyMs: performance.now() - start, rows: rangeResult.results.length };
            break;
          case 'aggregate':
            const aggResult = await d1.prepare('SELECT COUNT(*), AVG(value), MAX(value), MIN(value) FROM bench').all();
            result = { latencyMs: performance.now() - start, rows: 1 };
            break;
          case 'insert':
            await d1.prepare('INSERT OR REPLACE INTO bench (id, name, value, data) VALUES (?, ?, ?, ?)')
              .bind(id + 100000, \`bench_\${Date.now()}\`, Math.random(), \`data_\${Date.now()}\`).run();
            result = { latencyMs: performance.now() - start, rows: 1 };
            break;
        }
      }

      return Response.json({ success: true, system, operation, ...result });
    } catch (error) {
      return Response.json({ success: false, error: String(error) }, { status: 500 });
    }
  }
};
`;
}

// =============================================================================
// Wrangler Config Generator
// =============================================================================

function generateWranglerConfig(): string {
  return `{
  "name": "dosql-benchmark-compare",
  "main": "benchmark-worker.ts",
  "compatibility_date": "2026-01-01",

  "durable_objects": {
    "bindings": [
      { "name": "DOSQL_BENCHMARK", "class_name": "DoSQLBenchmarkDO" },
      { "name": "DOSQLITE_BENCHMARK", "class_name": "DOSqliteBenchmarkDO" }
    ]
  },

  "migrations": [
    { "tag": "v1", "new_sqlite_classes": ["DoSQLBenchmarkDO", "DOSqliteBenchmarkDO"] }
  ],

  "d1_databases": [
    {
      "binding": "BENCHMARK_D1",
      "database_name": "dosql-benchmark",
      "database_id": "YOUR_D1_DATABASE_ID"
    }
  ]
}`;
}

// =============================================================================
// Benchmark Runner
// =============================================================================

interface LatencyResult {
  min: number;
  max: number;
  avg: number;
  p50: number;
  p95: number;
  p99: number;
  samples: number;
}

function calculateStats(latencies: number[]): LatencyResult {
  if (latencies.length === 0) {
    return { min: 0, max: 0, avg: 0, p50: 0, p95: 0, p99: 0, samples: 0 };
  }

  const sorted = [...latencies].sort((a, b) => a - b);
  const sum = sorted.reduce((a, b) => a + b, 0);

  return {
    min: sorted[0],
    max: sorted[sorted.length - 1],
    avg: sum / sorted.length,
    p50: sorted[Math.floor(sorted.length * 0.5)],
    p95: sorted[Math.floor(sorted.length * 0.95)],
    p99: sorted[Math.floor(sorted.length * 0.99)],
    samples: sorted.length,
  };
}

async function runBenchmark(
  endpoint: string,
  system: string,
  operation: string,
  iterations: number,
  params: Record<string, string> = {}
): Promise<LatencyResult> {
  const latencies: number[] = [];

  for (let i = 0; i < iterations; i++) {
    const queryParams = new URLSearchParams({
      system,
      op: operation,
      id: String(Math.floor(Math.random() * 1000) + 1),
      ...params,
    });

    const start = performance.now();
    const response = await fetch(`${endpoint}?${queryParams}`);
    const totalLatency = performance.now() - start;

    const data = await response.json() as any;
    if (data.success) {
      // Always use RTT - this is what users actually experience
      // Server-side latency is too fast to measure reliably
      latencies.push(totalLatency);
    }
  }

  return calculateStats(latencies);
}

// =============================================================================
// Main
// =============================================================================

async function main() {
  const args = process.argv.slice(2);
  const isQuick = args.includes('--quick');
  const config = isQuick ? QUICK_CONFIG : DEFAULT_CONFIG;

  console.log('═══════════════════════════════════════════════════════════════════════');
  console.log('  DoSQL vs DO SQLite vs D1 - Cloudflare Workers Benchmark');
  console.log('═══════════════════════════════════════════════════════════════════════');
  console.log('');
  console.log('Configuration:');
  console.log(`  Iterations: ${config.iterations}`);
  console.log(`  Row Count: ${config.rowCount}`);
  console.log(`  Concurrency Levels: ${config.concurrency.join(', ')}`);
  console.log('');

  // Check if worker is deployed
  const endpoint = process.env.BENCHMARK_ENDPOINT;
  if (!endpoint) {
    console.log('⚠️  No BENCHMARK_ENDPOINT set.');
    console.log('');
    console.log('To run this benchmark:');
    console.log('');
    console.log('1. Create D1 database:');
    console.log('   wrangler d1 create dosql-benchmark');
    console.log('');
    console.log('2. Update wrangler config with D1 database ID');
    console.log('');
    console.log('3. Deploy the benchmark worker:');
    console.log('   wrangler deploy -c benchmark-wrangler.jsonc');
    console.log('');
    console.log('4. Set the endpoint and run:');
    console.log('   BENCHMARK_ENDPOINT=https://dosql-benchmark-compare.YOUR-SUBDOMAIN.workers.dev npx tsx benchmarks/worker-compare.ts');
    console.log('');

    // Generate files for deployment
    console.log('Generating deployment files...');

    const fs = await import('fs');
    fs.writeFileSync('benchmark-worker.ts', generateWorkerCode());
    fs.writeFileSync('benchmark-wrangler.jsonc', generateWranglerConfig());

    console.log('✓ Created benchmark-worker.ts');
    console.log('✓ Created benchmark-wrangler.jsonc');
    console.log('');
    console.log('Next: Update benchmark-wrangler.jsonc with your D1 database ID, then deploy.');
    return;
  }

  console.log(`Endpoint: ${endpoint}`);
  console.log('');

  // Systems to benchmark
  const systems = ['dosql', 'do-sqlite', 'd1'];
  const operations = ['select', 'range', 'aggregate', 'insert'];

  // Setup databases
  console.log('Setting up databases...');
  for (const system of systems) {
    try {
      await fetch(`${endpoint}?system=${system}&op=setup&rowCount=${config.rowCount}`);
      console.log(`  ✓ ${system} ready`);
    } catch (e) {
      console.log(`  ✗ ${system} failed: ${e}`);
    }
  }
  console.log('');

  // Run benchmarks
  const results: Record<string, Record<string, LatencyResult>> = {};

  for (const operation of operations) {
    console.log(`Running ${operation} benchmark...`);
    results[operation] = {};

    for (const system of systems) {
      try {
        const result = await runBenchmark(endpoint, system, operation, config.iterations);
        results[operation][system] = result;
        console.log(`  ${system}: p50=${result.p50.toFixed(2)}ms, p99=${result.p99.toFixed(2)}ms`);
      } catch (e) {
        console.log(`  ${system}: ERROR - ${e}`);
      }
    }
    console.log('');
  }

  // Print comparison table
  console.log('═══════════════════════════════════════════════════════════════════════');
  console.log('  RESULTS COMPARISON');
  console.log('═══════════════════════════════════════════════════════════════════════');
  console.log('');

  console.log('P50 Latency (ms):');
  console.log('┌──────────────┬──────────┬───────────┬──────────┬─────────────┐');
  console.log('│ Operation    │ DoSQL    │ DO-SQLite │ D1       │ Winner      │');
  console.log('├──────────────┼──────────┼───────────┼──────────┼─────────────┤');

  for (const op of operations) {
    const r = results[op];
    const dosql = r.dosql?.p50 ?? 999999;
    const doSqlite = r['do-sqlite']?.p50 ?? 999999;
    const d1 = r.d1?.p50 ?? 999999;
    const min = Math.min(dosql, doSqlite, d1);
    const winner = dosql === min ? 'DoSQL' : doSqlite === min ? 'DO-SQLite' : 'D1';

    console.log(`│ ${op.padEnd(12)} │ ${dosql.toFixed(2).padStart(8)} │ ${doSqlite.toFixed(2).padStart(9)} │ ${d1.toFixed(2).padStart(8)} │ ${winner.padEnd(11)} │`);
  }

  console.log('└──────────────┴──────────┴───────────┴──────────┴─────────────┘');
  console.log('');

  console.log('P99 Latency (ms):');
  console.log('┌──────────────┬──────────┬───────────┬──────────┬─────────────┐');
  console.log('│ Operation    │ DoSQL    │ DO-SQLite │ D1       │ Winner      │');
  console.log('├──────────────┼──────────┼───────────┼──────────┼─────────────┤');

  for (const op of operations) {
    const r = results[op];
    const dosql = r.dosql?.p99 ?? 999999;
    const doSqlite = r['do-sqlite']?.p99 ?? 999999;
    const d1 = r.d1?.p99 ?? 999999;
    const min = Math.min(dosql, doSqlite, d1);
    const winner = dosql === min ? 'DoSQL' : doSqlite === min ? 'DO-SQLite' : 'D1';

    console.log(`│ ${op.padEnd(12)} │ ${dosql.toFixed(2).padStart(8)} │ ${doSqlite.toFixed(2).padStart(9)} │ ${d1.toFixed(2).padStart(8)} │ ${winner.padEnd(11)} │`);
  }

  console.log('└──────────────┴──────────┴───────────┴──────────┴─────────────┘');
  console.log('');

  console.log('Note: Lower latency is better. DoSQL runs the full TypeScript SQL engine,');
  console.log('      while DO-SQLite and D1 use native SQLite. Performance difference');
  console.log('      reflects the tradeoff between portability and raw speed.');
}

main().catch(console.error);
